<!DOCTYPE html>
<html>
<head>
<title>Task2_Report.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="introduction">Introduction</h1>
<p>For Task 2, we have developed two distinct methods to calculate <strong>Customer Lifetime Value</strong> (CLV), a concept previously introduced in MKT 656. CLV is a crucial metric that estimates the total net earnings a business can expect from a single customer account throughout their relationship with the company. This metric is particularly useful in determining the cost of onboarding new prospects, enabling businesses to allocate resources appropriately based on the potential revenue generation of new customers.</p>
<p>CLV is particularly critical in industries with subscription-based models. As more businesses, including SaaS, eCommerce, and others, transition to subscription models, CLV becomes a vital indicator for customer segmentation and resource allocation.</p>
<p>There are numerous methodologies to calculate CLV, and our project adopts one of the simplest approaches, which will be detailed in the methodology section. A key feature of our approach is its direct integration with a SQL database. Unlike previous courses where we primarily worked with flat files, real-world applications often provide direct database access. This enables the potential to create data pipelines and integrate our functions across different parts of the production stack.</p>
<h1 id="methodology">Methodology</h1>
<p>This section details our CLV derivation and code related to the implementation.</p>
<h2 id="clv-derivation">CLV Derivation</h2>
<p>In order to calculate CLV, we will carry out the following calculations:</p>
<p><strong>Profit Per Order</strong>: This is calculated as the average net profit for each transaction.</p>
<p>$$\text{Profit Per Order} = \frac{\text{Total Profit from a Customer}}{\text{Total Number of Orders by the Customer}}$$</p>
<p><strong>Average Order Frequency</strong>: This represents the average number of orders a customer places per year. It's calculated by dividing the total number of orders by the lifespan of the customer in years.</p>
<p>$$\text{Avg. Order Frequency} = \frac{\text{Total Number of Orders by the Customer}}{\text{Customer's Lifespan in Years}} $$</p>
<p>To convert the customer's lifespan from days to years:</p>
<p>$$\text{Customer's Lifespan in Years} = \frac{\text{Customer's Lifespan in Days}}{365} $$</p>
<p><strong>Average Lifespan in Years</strong>: This is the average duration that a customer continues to buy from the business. It is calculated directly by converting the average lifespan from days to years.</p>
<p>$$ \text{Avg. Lifespan in Years} = \frac{\text{Mean Lifespan Days}}{365} $$</p>
<p><strong>Customer Lifetime Value (CLV)</strong>
Combining the above elements, the CLV for a customer can be calculated as:</p>
<p>$$ \text{CLV} = \text{Avg. Profit Per Order} \times \text{Avg. Order Frequency} \times \text{Avg. Lifespan in Years} $$</p>
<p>Where:</p>
<p><strong>Average Profit Per Order</strong> is the average net profit each order contributes.</p>
<p><strong>Average Order Frequency</strong> is how often a customer places an order in a year.</p>
<p><strong>Average Lifespan in Years</strong> is the average number of years a customer continues to engage with the business.</p>
<p>$$ \text{CLV} = \text{Mean Profit Per Order} \times \left( \frac{\text{Mean Order Amount}}{\text{Mean Lifespan Days} / 365} \right) \times \left( \frac{\text{Mean Lifespan Days}}{365} \right) $$</p>
<h2 id="programming">Programming</h2>
<p>Our program follows a simple function design and we adhered to the practice of one function does one thing.
<img src="Task2_Functions_Flow.svg" alt="Function Design Flow Chart"></p>
<hr>
<h3 id="function-initializedatabaseinstance">Function: <code>initializeDatabaseInstance()</code></h3>
<p><strong>Description:</strong><br>
Initializes an SQLite database instance in the repository, imports data from a CSV file, creates a table named <code>sales_data</code>, and fills it with the CSV data.</p>
<p><strong>Arguments:</strong><br>
None</p>
<p><strong>Returns:</strong><br>
None</p>
<hr>
<h3 id="function-initializedatabaseconnection">Function: <code>initializeDatabaseConnection()</code></h3>
<p><strong>Description:</strong><br>
Initializes an SQLite connection and cursor to the sales database. User still has to close the database connection after use with <code>conn.close()</code>.</p>
<p><strong>Arguments:</strong><br>
None</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>conn</code>: Connection to the database.</li>
<li><code>cursor</code>: Cursor for database operations.</li>
</ul>
<hr>
<h3 id="function-getuniquecustomers">Function: <code>getUniqueCustomers()</code></h3>
<p><strong>Description:</strong><br>
Generates a list of unique customers from the <code>sales_data</code> table in the database.</p>
<p><strong>Arguments:</strong><br>
None</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>list</code>: List of unique customers from the sales database table.</li>
</ul>
<hr>
<h3 id="function-getmetricsiterative">Function: <code>getMetricsIterative()</code></h3>
<p><strong>Description:</strong><br>
Calculates average quantities of orders, lifespan, total profit, and profit margin for each unique customer in the sales database.</p>
<p><strong>Arguments:</strong><br>
None</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dict</code>: Dictionary containing <code>meanOrderAmount</code>, <code>meanLifespanDays</code>, <code>meanTotalProfit</code>, and <code>meanProfitMargin</code>.</li>
</ul>
<hr>
<h3 id="function-getclviterative">Function: <code>getCLV_Iterative()</code></h3>
<p><strong>Description:</strong><br>
Calculates the Customer Lifetime Value (CLV) using average metrics calculated from the entire sales database.</p>
<p><strong>Arguments:</strong><br>
None</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>float</code>: Customer Lifetime Value.</li>
</ul>
<hr>
<h3 id="function-getmetricsrecursivedata-customerlist-index0-resultsnone">Function: <code>getMetricsRecursive(data, customerList, index=0, results=None)</code></h3>
<p><strong>Description:</strong><br>
Recursively calculates sales metrics such as average order quantities, lifespan, total profit, and profit margin. This function processes customers one at a time recursively, accumulating results.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>data</code> (<code>DataFrame</code>): Customer sales data table.</li>
<li><code>customerList</code> (<code>list</code>): List of unique customers, obtained from <code>getUniqueCustomers()</code>.</li>
<li><code>index</code> (<code>int</code>, optional): Current index in customer list. Default is 0.</li>
<li><code>results</code> (<code>dict</code>, optional): Stores intermediate results. Default is None.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dict</code>: Dictionary containing <code>meanOrderAmount</code>, <code>meanLifespanDays</code>, <code>meanTotalProfit</code>, and <code>meanProfitMargin</code>.</li>
</ul>
<hr>
<h3 id="function-getclvrecursivemetrics">Function: <code>getCLV_Recursive(metrics)</code></h3>
<p><strong>Description:</strong><br>
Calculates the Customer Lifetime Value (CLV) using metrics provided, processed recursively.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>metrics</code> (<code>dict</code>): Metrics dictionary containing average sales data metrics.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>float</code>: Customer Lifetime Value.</li>
</ul>
<hr>
<h3 id="function-getuniquecustomerssql">Function: <code>getUniqueCustomersSQL()</code></h3>
<p><strong>Description:</strong><br>
Fetches a distinct list of customer names directly from the SQL database using a DISTINCT query.</p>
<p><strong>Arguments:</strong><br>
None</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>list</code>: List of unique customer names from the sales database.</li>
</ul>
<hr>
<h3 id="function-getmetricsiterativesql">Function: <code>getMetricsIterativeSQL()</code></h3>
<p><strong>Description:</strong><br>
Directly computes sales metrics using SQL queries to perform aggregation functions. This method utilizes SQL to calculate and return average order amounts, lifespan days, total profit, and profit margins for each customer.</p>
<p><strong>Arguments:</strong><br>
None</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dict</code>: Dictionary containing average values of order amounts, lifespan days, total profit, and profit margins.</li>
</ul>
<hr>
<h3 id="function-getclviterativesql">Function: <code>getCLV_IterativeSQL()</code></h3>
<p><strong>Description:</strong><br>
Calculates the Customer Lifetime Value (CLV) using aggregated metrics obtained directly from SQL queries</p>
<p><strong>Arguments:</strong><br>
None</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>float</code>: Customer Lifetime Value.</li>
</ul>
<hr>
<h1 id="results">Results</h1>
<p>Present the outcomes of the performance analysis.</p>
<h1 id="discussion">Discussion</h1>
<p>Offer insights into the benefits and limitations of each implementation style.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Conclude with your recommendation on which version to use and under what circumstances.</p>

</body>
</html>
